//go:build ignore

package main

import (
	"fmt"
	"strings"
)

const (
	genDeBruijn = true  // print De Bruijn sequences
	genLogFunc  = true  // print De Bruijn sequence based log2 function
	genFixed    = true  // print fixed DEFLATE tables
	genPlain    = false // print uncompressed DEFLATE tables

	nsyms   = 286 // symbols
	ndcodes = 30  // distance codes
	nhcodes = 19  // header code length codes
)

func main() {
	fmt.Println(`// generated by go run gen.go; DO NOT EDIT

package qr`)

	var rev [nhcodes]int
	for i, v := range hcorder {
		rev[v] = i
	}
	fmt.Print(`
// Dynamic header code lengths order reverse index.  The order is:
//
//`,
		printSeq(hcorder[:], "\t", "%d", len(hcorder)),
		"var revhcorder = [nhcodes]byte{\n",
		printSeq(rev[:], "\t", "%d", len(rev)),
		"}\n")

	if genDeBruijn {
		// De Bruijn tables
		fmt.Println(`
// De Bruijn sequences for binary alphabet, used to generate byte
// frequencies for DEFLATE Huffman trees at various Code.Scale values.
var deBruijn2 = [4]struct {
	seq    uint16
	length byte
}{`)
		for i := 1; i <= 4; i++ {
			fmt.Println(deBruijn2(i))
		}
		fmt.Println("}")
	}

	if genLogFunc {
		fmt.Println(deBruijn2(5).logFunc())
	}

	if genFixed {
		// Symbols
		var c [nsyms]code
		var this = code{nbit: 7}
		for i := 256; i < 280; i++ {
			c[i] = this.inc()
		}
		this.nbit = 8
		for i := 0; i < 144; i++ {
			c[i] = this.inc()
		}
		for i := 280; i < len(c); i++ {
			c[i] = this.inc()
		}
		this.inc() // 11000110 wasted
		this.inc() // 11000111 wasted
		this.nbit = 9
		for i := 144; i < 256; i++ {
			c[i] = this.inc()
		}
		fmt.Println(`
// Flate symbol table for fixed blocks.
var fixedSym = [nsyms]code{`)
		for i, v := range c[:nsyms] {
			fmt.Printf("%-29s //  %3d  %s\n", v, i, v.rev())
		}
		fmt.Println("}")

		// Distance codes
		fmt.Println(`
// Flate distance code table for fixed blocks.
var fixedDist = [ndcodes]code{
	//                                Extra
	//                          Code  Bits   Distance
	//                          ----  ----  -----------`)
		this = code{nbit: 5}
		for i := 0; i < ndcodes; i++ {
			fmt.Println(this.inc(), "//", distComment(i))
		}
		// 11110, 11111 wasted
		fmt.Println("}")
	}

	if genPlain {
		fmt.Println(`
// Flate symbol table for uncompressed blocks.
var uncompressedSym = [257]code{`)
		for i := 0; i < 0x100; i++ {
			fmt.Printf("\t{bit: %#02x, nbit: 8},\n", i)
		}
		fmt.Println("\t{}, // empty end of stream code\n}")
	}
}

var hcorder = [nhcodes]int{
	16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
}

func printSeq(s []int, p, f string, n int) string {
	f = "%s" + f + ",%s"
	var b strings.Builder
	for i, v := range s {
		pref, suf := " ", ""
		switch i % n {
		case 0:
			pref = p
		case n - 1:
			suf = "\n"
		}
		fmt.Fprintf(&b, f, pref, v, suf)
	}
	return b.String()
}

// Huffman tree symbol
type code struct {
	bit  uint16 // value
	nbit uint16 // bit length
}

func (c *code) inc() code {
	cc := *c
	hi := uint16(1) << c.nbit
	lo := hi >> 1
	for c.bit&lo != 0 {
		lo >>= 1
	}
	c.bit ^= hi - lo
	return cc
}

func (c code) rev() string {
	s := make([]byte, c.nbit)
	for i := range s {
		s[i] = byte('0' + c.bit&1)
		c.bit >>= 1
	}
	return string(s)
}

func (c code) String() string {
	return fmt.Sprintf("\t{bit: %#0*b, nbit: %d},", c.nbit, c.bit, c.nbit)
}

// distance codes offset base
var dcodes = [ndcodes]int{
	1, 2, 3, 4, 5, 7, 9, 13, 17, 25,
	33, 49, 65, 97, 129, 193, 257, 385, 513, 769,
	1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577,
}

// distance codes extra bits
var dext = [ndcodes]byte{
	0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
	4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
	9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
}

func distComment(n int) string {
	lo, ext := dcodes[n], dext[n]
	hi := lo + 1<<ext - 1
	s := fmt.Sprintf("%3d %5d   ", n, ext)
	switch ext {
	case 0:
		s += fmt.Sprintf("%6d", lo)
	case 1:
		s += fmt.Sprintf("%5d,%d", lo, hi)
	default:
		s += fmt.Sprintf("%5d-%d", lo, hi)
	}
	return s
}

// deBruijn word or sequence over binary alphabet
type dbWord struct {
	bits uint64 // word/sequence
	len  int    // bit length
	n    int    // sequence word length
}

var dbComment = []string{
	"",
	"scale N*8",
	"scale 4, 6, 7, >8 except N*8",
	"scale 5",
	"scale 2, 3",
}

func (w dbWord) String() string {
	s := fmt.Sprintf("{%#0*b, 1 << %d},", w.len, w.bits, w.n)
	return fmt.Sprintf("\t%-29s // B(2,%d)  %s", s, w.n, dbComment[w.n])
}

// next returns the Lyndon word of length <=word.n over binary
// alphabet lexicographically following word, or word with len zero
// if word represents the last Lyndon word in the sequence.
// The result is generated using Duval's algorithm.
func (w dbWord) next() dbWord {
	for w.bits <<= (w.n - w.len); w.len < w.n; w.len <<= 1 {
		w.bits |= w.bits >> w.len
	}
	w.len = w.n
	for w.bits++; w.bits&1 == 0; w.bits >>= 1 {
		w.len--
	}
	return w
}

// deBruijn2 generates a De Bruijn sequence of words of length n
// over binary alphabet (B(2, n)) by concatenating Lyndon words of
// length dividing n in lexicographic order.
func deBruijn2(n int) dbWord {
	var seq = dbWord{n: n}
	for word := (dbWord{len: 1, n: n}); word.len != 0; word = word.next() {
		if n%word.len == 0 {
			seq.bits = seq.bits<<word.len | word.bits
			seq.len += word.len
		}
	}
	if seq.len != 1<<n {
		panic("De Bruijn sequence")
	}
	return seq
}

// rev returns the reverse indices for seq.
func (seq dbWord) rev() []int {
	r := make([]int, seq.len)
	mask := uint64(seq.len - 1)
	shift := uint64(seq.len - seq.n)
	for i := 0; i < seq.len; i++ {
		r[seq.bits>>shift&mask] = i
		seq.bits <<= 1
	}
	return r
}

// logFunc returns a log2 function definition.  It's only good for
// B(2,3) to B(2,6) (8 to 64 bit sequences).
func (seq dbWord) logFunc() string {
	var seqs string
	if seq.len < 64 {
		seqs = fmt.Sprintf("%#0*b", seq.len, seq.bits)
	} else {
		seqs = fmt.Sprintf("%#0*x", seq.len/4, seq.bits)
	}
	revs := "\n" + printSeq(seq.rev(), "\t\t", "%d", 16) + "\t"
	if seq.len == 8 {
		revs = revs[3 : len(revs)-2]
	}
	return fmt.Sprintf(`
// log2 returns the base 2 logarithm of a %d-bit integer with one bit set.
func log2(bit uint%d) int {
	return int([%d]uint8{%s}[%s*bit>>%d])
}`,
		seq.len, seq.len, seq.len, revs, seqs, seq.len-seq.n)
}
